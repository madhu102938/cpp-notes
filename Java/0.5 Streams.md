# **Notes on Predicate, Function, Consumer, and Supplier in Java**

These are functional interfaces introduced in Java 8 as part of the `java.util.function` package, used for implementing functional programming paradigms in Java.

---

### **1. Predicate**

- **Definition**: Represents a `boolean`-valued function (a condition) that takes one argument.
    
- **Functional Method**: `boolean test(T t)`
    
- **Usage**:
    
    - Used for evaluating conditions like filters or matches.
    - Often used with streams for filtering.
- **Example**:
    
    ```java
    Predicate<Integer> isEven = number -> number % 2 == 0;
    
    System.out.println(isEven.test(4));  // true
    System.out.println(isEven.test(5));  // false
    ```
    
- **Internal Implementation**:
    
    - Predicate is a functional interface with only one method:
        
        ```java
        @FunctionalInterface
        public interface Predicate<T> {
            boolean test(T t);
        }
        ```
        
- **Key Methods**:
    
    - `and(Predicate other)`: Combines two predicates with logical AND.
    - `or(Predicate other)`: Combines two predicates with logical OR.
    - `negate()`: Negates the predicate.

---

### **2. Function**

- **Definition**: Represents a function that accepts one argument and produces a result.
    
- **Functional Method**: `R apply(T t)`
    
- **Usage**:
    
    - Used for transforming data, e.g., converting one type to another.
    - Often used with map operations in streams.
- **Example**:
    
    ```java
    Function<String, Integer> lengthFunction = str -> str.length();
    
    System.out.println(lengthFunction.apply("hello"));  // 5
    ```
    
- **Internal Implementation**:
    
    - Function is a functional interface with one method:
        
        ```java
        @FunctionalInterface
        public interface Function<T, R> {
            R apply(T t);
        }
        ```
        
- **Key Methods**:
    
    - `andThen(Function after)`: Chains another function to execute after the current one.
    - `compose(Function before)`: Chains another function to execute before the current one.

---

### **3. Consumer**

- **Definition**: Represents an operation that accepts a single input argument and returns no result.
    
- **Functional Method**: `void accept(T t)`
    
- **Usage**:
    
    - Used for performing actions (like printing or logging).
    - Often used with `forEach` in streams.
- **Example**:
    
    ```java
    Consumer<String> printConsumer = str -> System.out.println(str);
    
    printConsumer.accept("Hello, World!");  // Prints: Hello, World!
    ```
    
- **Internal Implementation**:
    
    - Consumer is a functional interface with one method:
        
        ```java
        @FunctionalInterface
        public interface Consumer<T> {
            void accept(T t);
        }
        ```
        
- **Key Methods**:
    
    - `andThen(Consumer after)`: Chains another consumer to execute after the current one.

---

### **4. Supplier**

- **Definition**: Represents a function that produces a result without accepting any arguments.
    
- **Functional Method**: `T get()`
    
- **Usage**:
    
    - Used for generating values, e.g., random numbers or object creation.
- **Example**:
    
    ```java
    Supplier<Double> randomSupplier = () -> Math.random();
    
    System.out.println(randomSupplier.get());  // Prints a random double value
    ```
    
- **Internal Implementation**:
    
    - Supplier is a functional interface with one method:
        
        ```java
        @FunctionalInterface
        public interface Supplier<T> {
            T get();
        }
        ```
        

---

### **Summary of Functional Interfaces**

|**Interface**|**Description**|**Functional Method**|**Example**|
|---|---|---|---|
|Predicate|Evaluates a condition and returns a boolean.|`boolean test(T t)`|`x -> x > 10`|
|Function|Transforms an input into an output.|`R apply(T t)`|`x -> x.toString()`|
|Consumer|Performs an action without returning a result.|`void accept(T t)`|`x -> System.out.println(x)`|
|Supplier|Generates a value without taking any input.|`T get()`|`() -> Math.random()`|

---

### **Why Use Them?**

- Enable concise and readable code with **lambdas**.
- Reduce boilerplate code by replacing anonymous classes.
- Make stream operations and functional programming more expressive.


--- 
# **Notes on Bi-Functional Interfaces and Specialized Interfaces**

---

### **1. Bi-Functional Interfaces**

Bi-functional interfaces are variants of functional interfaces that take **two arguments** instead of one. They are useful for operations involving pairs of inputs.

---

#### **1.1 BiPredicate**

- **Definition**: Represents a condition that takes two arguments and returns a boolean.
- **Functional Method**: `boolean test(T t, U u)`
- **Usage**:
    - Used for conditions involving two inputs.
- **Example**:
    
    ```java
    BiPredicate<Integer, Integer> isGreater = (a, b) -> a > b;
    
    System.out.println(isGreater.test(5, 3));  // true
    System.out.println(isGreater.test(2, 4));  // false
    ```
    

---

#### **1.2 BiFunction**

- **Definition**: Represents a function that accepts two arguments and produces a result.
- **Functional Method**: `R apply(T t, U u)`
- **Usage**:
    - Used for combining or transforming two inputs into an output.
- **Example**:
    
    ```java
    BiFunction<String, String, String> concat = (s1, s2) -> s1 + s2;
    
    System.out.println(concat.apply("Hello, ", "World!"));  // Hello, World!
    ```
    

---

#### **1.3 BiConsumer**

- **Definition**: Represents an operation that accepts two arguments and returns no result.
- **Functional Method**: `void accept(T t, U u)`
- **Usage**:
    - Used for performing actions involving two inputs (e.g., logging paired data).
- **Example**:
    
    ```java
    BiConsumer<String, Integer> printPerson = (name, age) -> System.out.println(name + " is " + age + " years old");
    
    printPerson.accept("Alice", 25);  // Alice is 25 years old
    ```
    

---

### **2. Specialized Functional Interfaces**

#### **2.1 UnaryOperator**

- **Definition**: A `Function` specialization that takes one argument and produces a result of the same type.
- **Functional Method**: `T apply(T t)`
- **Usage**:
    - Used for operations that transform a value into the same type.
- **Example**:
    
    ```java
    UnaryOperator<Integer> square = x -> x * x;
    
    System.out.println(square.apply(4));  // 16
    ```
    

---

#### **2.2 BinaryOperator**

- **Definition**: A `BiFunction` specialization that takes two arguments of the same type and produces a result of the same type.
- **Functional Method**: `T apply(T t1, T t2)`
- **Usage**:
    - Used for reducing or combining two values of the same type.
- **Example**:
    
    ```java
    BinaryOperator<Integer> add = (a, b) -> a + b;
    
    System.out.println(add.apply(5, 10));  // 15
    ```
    

---

#### **2.3 TernaryOperator**

- **Definition**: Represents a **conceptual extension** (though not a direct interface in Java) for operations with **three inputs**.
- **Usage**:
    - Not directly available in Java. You can use a `TriFunction` (custom functional interface).
- **Example** (custom `TriFunction`):
    
    ```java
    @FunctionalInterface
    interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }
    
    TriFunction<Integer, Integer, Integer, Integer> maxOfThree = (a, b, c) -> Math.max(a, Math.max(b, c));
    
    System.out.println(maxOfThree.apply(3, 7, 5));  // 7
    ```
    

---

### **3. Summary Table**

|**Interface**|**Description**|**Example**|
|---|---|---|
|**Predicate**|Condition with 1 argument.|`x -> x > 5`|
|**BiPredicate**|Condition with 2 arguments.|`(x, y) -> x > y`|
|**Function**|Transform 1 argument to a result.|`x -> x.toString()`|
|**BiFunction**|Transform 2 arguments to a result.|`(x, y) -> x + y`|
|**Consumer**|Action with 1 argument, no result.|`x -> System.out.println(x)`|
|**BiConsumer**|Action with 2 arguments, no result.|`(x, y) -> System.out.println(x + y)`|
|**Supplier**|Generates a value with no argument.|`() -> Math.random()`|
|**UnaryOperator**|Transform a value into the same type.|`x -> x * x`|
|**BinaryOperator**|Combine 2 values of the same type into 1.|`(x, y) -> x + y`|
|**TernaryOperator**|Custom: Transform 3 arguments into 1 result (not predefined).|`(x, y, z) -> Math.max(x, Math.max(y, z))`|

---

### **Why These Interfaces Are Important**

- They simplify functional programming by enabling concise expressions using **lambda functions**.
- They are heavily used in **streams**, **collections**, and **parallel processing**.

---
# **Method Reference**

- **Definition**: A shorthand way of referring to a method (static or instance) using `::` instead of a lambda expression.
- **Purpose**: Simplifies lambda expressions by directly referencing existing methods.
- **Syntax**: `ClassName::methodName` or `objectName::methodName`.

#### **Types of Method References**

1. **Static Method Reference**  
    Syntax: `ClassName::staticMethodName`  
    Example:
    
    ```java
    // Lambda
    Function<Integer, Double> sqrtLambda = x -> Math.sqrt(x);
    // Method Reference
    Function<Integer, Double> sqrtMethodRef = Math::sqrt;
    
    System.out.println(sqrtMethodRef.apply(16));  // 4.0
    ```
    
2. **Instance Method Reference**  
    Syntax: `objectName::instanceMethodName`  
    Example:
    
    ```java
    String str = "hello";
    Supplier<String> toUpperCase = str::toUpperCase;
    
    System.out.println(toUpperCase.get());  // HELLO
    ```
    
3. **Instance Method of an Arbitrary Object**  
    Syntax: `ClassName::instanceMethodName`  
    Example:
    
    ```java
    List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
    names.forEach(System.out::println);  // Prints each name
    ```
    
4. **Constructor Reference**  
    Syntax: `ClassName::new`  
    Example:
    
    ```java
    Supplier<List<String>> listSupplier = ArrayList::new;
    List<String> list = listSupplier.get();
    ```
    

---

# **Constructor Reference**

- **Definition**: A type of method reference used to create an instance of a class by referring to its constructor.
- **Purpose**: Eliminates the need for a lambda that only calls a constructor.

#### **Example with Constructor Reference**

```java
import java.util.function.Supplier;

class Person {
    String name;

    Person() {
        this.name = "Unknown";
    }
}

// Constructor Reference
Supplier<Person> personSupplier = Person::new;
Person person = personSupplier.get();
System.out.println(person.name);  // Unknown
```

---

### **Comparison Between Lambda and Method/Constructor Reference**

|**Feature**|**Lambda Expression**|**Method/Constructor Reference**|
|---|---|---|
|**Syntax**|`() -> new Object()`|`Object::new`|
|**Usage**|Explicitly defines the method body|Refers directly to an existing method/constructor|
|**Readability**|Slightly verbose in repetitive cases|More concise and readable|
|**Performance**|Same as lambda expressions|Same as lambda expressions|

---

### **Advantages**

- Increases code **readability** and **reusability**.
- Avoids verbose lambda syntax when the body is a direct method call.

### **Use Cases**

- **Streams API**: Method references and constructor references are heavily used in Java's functional programming model, such as `map`, `filter`, and `collect`.

--- 
# **Streams in Java**

#### **What are Streams?**

- **Definition**: Streams in Java provide a high-level abstraction for processing sequences of elements in a functional programming style.
- **Purpose**: To process data collections like arrays, lists, and sets efficiently and concisely.
- **Features**:
    - **Lazy Evaluation**: Operations are performed only when a terminal operation is invoked.
    - **Pipelining**: Intermediate operations are chained, forming a pipeline.
    - **Immutability**: Original data structures remain unchanged.
    - **Parallel Processing**: Streams support parallel execution.

---

### **Types of Stream Operations**

1. **Source**
    
    - Definition: The starting point of a stream, like collections or arrays.
    - Examples:
        
        ```java
        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> stream = list.stream();
        ```
        
2. **Intermediate Operations**
    
    - Definition: Transform the stream without consuming it. These operations are lazy and return another stream.
    - Examples:
        - **Filter**: Filters elements based on a condition.
            
            ```java
            List<Integer> filtered = numbers.stream()
                                            .filter(x -> x % 2 == 0)
                                            .collect(Collectors.toList());
            ```
            
        - **Map**: Transforms each element.
            
            ```java
            List<String> mapped = list.stream()
                                      .map(String::toUpperCase)
                                      .collect(Collectors.toList());
            ```
            
        - **Sorted**: Sorts elements.
            
            ```java
            List<Integer> sorted = numbers.stream()
                                          .sorted()
                                          .collect(Collectors.toList());
            ```
            
3. **Terminal Operations**
    
    - Definition: Ends the stream pipeline, triggering the processing of all operations.
    - Examples:
        - **forEach**: Performs an action on each element.
            
            ```java
            numbers.stream().forEach(System.out::println);
            ```
            
        - **collect**: Collects elements into a collection.
            
            ```java
            List<Integer> list = numbers.stream().collect(Collectors.toList());
            ```
            
        - **reduce**: Reduces elements to a single value.
            
            ```java
            int sum = numbers.stream().reduce(0, Integer::sum);
            ```
            
        - **count**: Counts elements.
            
            ```java
            long count = numbers.stream().count();
            ```

--- 
### **How to Declare Streams**

#### 1. **From Collections**

```java
import java.util.*;
import java.util.stream.*;

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Stream from a collection
Stream<Integer> stream = numbers.stream();
```

#### 2. **From Arrays**

```java
int[] array = {1, 2, 3, 4, 5};

// Stream from an array
IntStream streamFromArray = Arrays.stream(array);
```

#### 3. **Infinite Streams**

- Created using **Supplier** or **UnaryOperator**.
- **Example with `Supplier`**:

```java
import java.util.stream.*;

Stream<Double> infiniteStream = Stream.generate(Math::random);  // Infinite stream of random numbers
infiniteStream.limit(5).forEach(System.out::println);  // Prints 5 random numbers
```

- **Example with `UnaryOperator`**:

```java
Stream<Integer> infiniteStream = Stream.iterate(0, n -> n + 2);  // Even numbers
infiniteStream.limit(5).forEach(System.out::println);  // 0, 2, 4, 6, 8
```

---

### **Key Points**

- **Stream Pipeline**: A stream pipeline is composed of:
    - A **source** (e.g., collection, array, infinite stream).
    - **Intermediate operations** to process data (lazy evaluation).
    - A **terminal operation** to produce a result (eager evaluation).

### **Example**

```java
import java.util.*;
import java.util.stream.*;

public class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Pipeline: Source → Intermediate → Terminal
        List<Integer> result = numbers.stream()
                                      .filter(x -> x % 2 == 0)    // Intermediate
                                      .map(x -> x * x)           // Intermediate
                                      .sorted()                  // Intermediate
                                      .collect(Collectors.toList());  // Terminal

        System.out.println(result);  // Output: [4, 16]
    }
}
```

--- 
# **Intermediate Operations in Streams**

Intermediate operations are used to process and transform data within a stream pipeline. These operations are lazy, meaning they don’t perform any computation until a terminal operation is invoked.

---

#### 1. **Filter**

- **Definition**: Filters elements based on a condition (predicate).
- **Example**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
List<Integer> evenNumbers = numbers.stream()
                                   .filter(n -> n % 2 == 0)
                                   .collect(Collectors.toList());
System.out.println(evenNumbers);  // Output: [2, 4, 6]
```

---

#### 2. **Map**

- **Definition**: Transforms each element using a function.
- **Example**:

```java
List<String> names = Arrays.asList("alice", "bob", "charlie");
List<String> upperCaseNames = names.stream()
                                   .map(String::toUpperCase)
                                   .collect(Collectors.toList());
System.out.println(upperCaseNames);  // Output: [ALICE, BOB, CHARLIE]
```

---

#### 3. **Sorted**

- **Definition**: Sorts the elements of a stream.
- **Example**:

```java
List<Integer> numbers = Arrays.asList(4, 2, 5, 3, 1);
List<Integer> sortedNumbers = numbers.stream()
                                     .sorted()
                                     .collect(Collectors.toList());
System.out.println(sortedNumbers);  // Output: [1, 2, 3, 4, 5]
```

---

#### 4. **Distinct**

- **Definition**: Removes duplicate elements.
- **Example**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 4, 4);
List<Integer> distinctNumbers = numbers.stream()
                                       .distinct()
                                       .collect(Collectors.toList());
System.out.println(distinctNumbers);  // Output: [1, 2, 3, 4]
```

---

#### 5. **Limit**

- **Definition**: Truncates the stream to a specified number of elements.
- **Example**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> limitedNumbers = numbers.stream()
                                      .limit(3)
                                      .collect(Collectors.toList());
System.out.println(limitedNumbers);  // Output: [1, 2, 3]
```

---

#### 6. **Skip**

- **Definition**: Skips the first `n` elements of the stream.
- **Example**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> skippedNumbers = numbers.stream()
                                      .skip(2)
                                      .collect(Collectors.toList());
System.out.println(skippedNumbers);  // Output: [3, 4, 5]
```

---

### **What is Lazy Evaluation?**

- **Definition**: Lazy evaluation means intermediate operations are not executed immediately. Instead, they are recorded and only executed when a terminal operation is invoked.
- **How it works**:
    - A stream operation creates a pipeline of operations.
    - No intermediate operation processes data until a terminal operation is called.
    - This improves performance by avoiding unnecessary computations.

**Example of Lazy Evaluation**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .filter(n -> {
           System.out.println("Filter: " + n);
           return n % 2 == 0;
       })  // No filtering happens yet
       .map(n -> {
           System.out.println("Map: " + n);
           return n * n;
       });  // Still no processing
// No terminal operation, so no output
```

If you add a terminal operation:

```java
List<Integer> result = numbers.stream()
                              .filter(n -> {
                                  System.out.println("Filter: " + n);
                                  return n % 2 == 0;
                              })
                              .map(n -> {
                                  System.out.println("Map: " + n);
                                  return n * n;
                              })
                              .collect(Collectors.toList());
System.out.println(result);
// Output will show the operations performed on only the necessary elements.
```

--- 
# **Terminal Operations in Streams**

Terminal operations are used to produce a result or a side-effect from the stream pipeline. Once a terminal operation is invoked, the stream pipeline is executed, and the stream is no longer usable.

---

#### 1. **Collect**

- **Definition**: Gathers elements of the stream into a collection or other forms.
- **Example**:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> uppercaseNames = names.stream()
                                   .map(String::toUpperCase)
                                   .collect(Collectors.toList());
System.out.println(uppercaseNames);  // Output: [ALICE, BOB, CHARLIE]
```

---

#### 2. **ForEach**

- **Definition**: Performs an action for each element in the stream.
- **Example**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().forEach(n -> System.out.println(n));
// Output: 1 2 3 4 5 (printed line by line)
```

---

#### 3. **Count**

- **Definition**: Returns the count of elements in the stream.
- **Example**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
long count = numbers.stream().filter(n -> n % 2 == 0).count();
System.out.println(count);  // Output: 2
```

---

#### 4. **Reduce**

- **Definition**: Reduces the elements of a stream into a single value by repeatedly applying a function.
    
- **Syntax**:
    
    - `T reduce(T identity, BinaryOperator<T> accumulator)`
    - `Optional<T> reduce(BinaryOperator<T> accumulator)`
- **Example (with identity)**:
    

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
int sum = numbers.stream().reduce(0, (a, b) -> a + b);
System.out.println(sum);  // Output: 10
```

- **Example (without identity)**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);
Optional<Integer> product = numbers.stream().reduce((a, b) -> a * b);
product.ifPresent(System.out::println);  // Output: 24
```

---

#### 5. **Optional Type**

- **Definition**: A container object used to represent a value that might be null, avoiding `NullPointerException`.
- **Methods**:
    - `isPresent()`: Checks if a value is present.
    - `orElse(T other)`: Returns the value if present, or the default value otherwise.
    - `ifPresent(Consumer<? super T> action)`: Executes a block of code if the value is present.

---

#### 6. **AnyMatch, AllMatch, NoneMatch**

- **Definition**: Used to test elements against a predicate.
- **Examples**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);

boolean anyMatch = numbers.stream().anyMatch(n -> n > 3);
System.out.println(anyMatch);  // Output: true

boolean allMatch = numbers.stream().allMatch(n -> n > 0);
System.out.println(allMatch);  // Output: true

boolean noneMatch = numbers.stream().noneMatch(n -> n < 0);
System.out.println(noneMatch);  // Output: true
```

---

#### 7. **FindFirst, FindAny**

- **Definition**: Used to retrieve elements from a stream.
- **Examples**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4);

Optional<Integer> first = numbers.stream().findFirst();
first.ifPresent(System.out::println);  // Output: 1

Optional<Integer> any = numbers.stream().findAny();
any.ifPresent(System.out::println);  // Output: (could be any element)
```

---

### **How to Convert a String to a Stream of Characters**

- **Example**:

```java
String str = "hello";
Stream<Character> charStream = str.chars().mapToObj(c -> (char) c);
charStream.forEach(System.out::println);
// Output: h e l l o (printed line by line)
```

This uses `String.chars()` to convert the string into an `IntStream`, which is then mapped to characters using `mapToObj`.

--- 
# **Stateful and Stateless Operations in Streams**

In Java Streams, operations can be categorized as **stateful** or **stateless**, depending on whether they maintain any internal state while processing elements.

---

### **1. Stateless Operations**

- **Definition**: These operations process each element of the stream independently without requiring information about other elements or maintaining state.
- **Examples**:
    - `filter()`
    - `map()`
    - `flatMap()`
    - `forEach()`
- **Characteristics**:
    - No intermediate storage or state is required.
    - Highly efficient and parallelizable.
- **Example**:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream()
       .filter(n -> n % 2 == 0)
       .forEach(System.out::println);
// Output: 2 4
```

---

### **2. Stateful Operations**

- **Definition**: These operations require maintaining state to process elements, often involving all elements before producing a result.
- **Examples**:
    - `distinct()`
    - `sorted()`
    - `limit()`
    - `skip()`
- **Characteristics**:
    - May need to buffer, reorder, or analyze multiple elements.
    - Less efficient, especially for large datasets, as they may block further processing until sufficient data is available.
- **Example**:

```java
List<Integer> numbers = Arrays.asList(5, 2, 1, 4, 3);
numbers.stream()
       .sorted()
       .forEach(System.out::println);
// Output: 1 2 3 4 5
```

---

### **Key Differences**

|**Stateless Operations**|**Stateful Operations**|
|---|---|
|Do not require internal state.|Require internal state or buffering.|
|Process elements immediately.|May delay processing until all elements are available.|
|Examples: `filter()`, `map()`|Examples: `sorted()`, `distinct()`|

Stateless operations are generally more efficient and better suited for parallel processing. Stateful operations, while useful, may introduce performance overhead, especially for large datasets.